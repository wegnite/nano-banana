# 性能优化建议

## 📊 当前性能分析

基于项目代码分析和构建输出，以下是针对 Vercel 部署的性能优化建议。

### 构建分析摘要
- **总路由数量：** 52个路由
- **最大页面大小：** 988 kB (admin/posts 编辑页面)
- **首页大小：** 730 kB
- **共享 JS：** 101 kB
- **中间件大小：** 43.5 kB

## 🎯 核心优化策略

### 1. JavaScript Bundle 优化

#### 问题分析
- 管理后台页面过大（988 kB）
- 首页加载负担重（730 kB）
- 某些页面包含过多 JavaScript

#### 优化方案

**A. 代码分割优化**
```typescript
// 懒加载重组件
const AIGenerator = dynamic(() => import('@/components/blocks/ai-generator'), {
  loading: () => <div>Loading AI Generator...</div>,
  ssr: false // 对于纯客户端组件
});

const AdminPosts = dynamic(() => import('@/components/admin/posts'), {
  loading: () => <AdminSkeleton />,
});
```

**B. Bundle Analyzer 配置**
```bash
# 开启 bundle 分析
ANALYZE=true npm run build
```

**C. 第三方库优化**
```typescript
// 按需引入
import { Button } from '@/components/ui/button';
// 而不是
import * as UI from '@/components/ui';

// Tree shaking 优化
import { debounce } from 'lodash/debounce';
// 而不是
import _ from 'lodash';
```

### 2. 图片优化策略

#### 问题分析
构建日志显示多处使用 `<img>` 标签而非 Next.js Image 组件。

#### 优化方案

**A. 统一使用 Next.js Image**
```typescript
import Image from 'next/image';

// 替换所有 <img> 标签
<Image
  src="/imgs/features/1.png"
  alt="Feature description"
  width={800}
  height={600}
  priority={isAboveFold}
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
/>
```

**B. Cloudflare R2 + 图片优化**
```typescript
// 配置图片优化域名
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'pub-*.r2.dev', // 你的 R2 域名
        pathname: '/**',
      },
    ],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
};
```

**C. 图片格式优化**
```typescript
// 优先使用现代图片格式
const imageFormats = {
  webp: 'image/webp',
  avif: 'image/avif',
  jpeg: 'image/jpeg'
};

// 响应式图片
<Image
  src="/image.jpg"
  alt="Description"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  width={1200}
  height={800}
/>
```

### 3. API 路由优化

#### 问题分析
- 大量 API 路由可能影响冷启动
- AI API 调用可能耗时较长

#### 优化方案

**A. API 响应缓存**
```typescript
// 在 API 路由中添加缓存
export async function GET(request: NextRequest) {
  const response = NextResponse.json(data);
  
  // 设置缓存头
  response.headers.set('Cache-Control', 'public, s-maxage=60, stale-while-revalidate=300');
  
  return response;
}
```

**B. Edge Runtime 优化**
```typescript
// 对于简单的 API 使用 Edge Runtime
export const runtime = 'edge';

export async function GET(request: Request) {
  // 快速响应的逻辑
}
```

**C. API 超时和重试**
```typescript
// nano-banana service 已实现，继续优化
const TIMEOUT_CONFIG = {
  short: 5000,   // 5s for quick operations
  medium: 30000, // 30s for AI generation
  long: 60000,   // 60s for complex operations
};
```

### 4. 数据库查询优化

#### 优化方案

**A. 连接池优化**
```typescript
// 在 db/config.ts 中优化连接池
const config = {
  connectionString: process.env.DATABASE_URL,
  max: 20, // 最大连接数
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
};
```

**B. 查询优化**
```typescript
// 使用索引和 limit
async function getUserCredits(user_uuid: string, limit = 100) {
  return await db
    .select()
    .from(credits)
    .where(eq(credits.user_uuid, user_uuid))
    .orderBy(desc(credits.created_at))
    .limit(limit);
}

// 批量操作
async function batchUpdateCredits(updates: CreditUpdate[]) {
  return await db.transaction(async (tx) => {
    for (const update of updates) {
      await tx.update(credits).set(update).where(eq(credits.id, update.id));
    }
  });
}
```

### 5. 缓存策略

#### A. Redis 缓存层
```typescript
// 添加 Redis 缓存
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL,
  token: process.env.UPSTASH_REDIS_REST_TOKEN,
});

// 缓存用户积分
export async function getCachedUserCredits(user_uuid: string) {
  const cached = await redis.get(`credits:${user_uuid}`);
  if (cached) return cached;
  
  const credits = await getUserCredits(user_uuid);
  await redis.setex(`credits:${user_uuid}`, 300, JSON.stringify(credits)); // 5分钟缓存
  
  return credits;
}
```

#### B. 静态资源缓存
```typescript
// next.config.mjs 中配置缓存头
const nextConfig = {
  async headers() {
    return [
      {
        source: '/imgs/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};
```

### 6. 国际化优化

#### 问题分析
多语言内容可能影响首页加载速度。

#### 优化方案
```typescript
// 懒加载语言包
const loadMessages = async (locale: string) => {
  switch (locale) {
    case 'zh':
      return (await import('@/i18n/messages/zh.json')).default;
    case 'en':
    default:
      return (await import('@/i18n/messages/en.json')).default;
  }
};
```

## 🚀 Vercel 特定优化

### 1. Vercel Functions 优化

**A. 函数配置**
```json
// vercel.json
{
  "functions": {
    "app/api/nano-banana/**/*": {
      "maxDuration": 60,
      "memory": 1024
    },
    "app/api/demo/**/*": {
      "maxDuration": 30,
      "memory": 512
    },
    "app/api/**/*": {
      "maxDuration": 10,
      "memory": 256
    }
  },
  "regions": ["hkg1", "nrt1"], // 选择距离用户最近的区域
  "framework": "nextjs"
}
```

**B. 边缘配置**
```typescript
// 对于静态内容使用边缘函数
export const config = {
  runtime: 'edge',
  regions: ['hkg1', 'nrt1'], // 亚太地区
};
```

### 2. ISR (增量静态再生成) 配置

```typescript
// 对于相对静态的页面使用 ISR
export async function generateStaticParams() {
  return [
    { locale: 'en' },
    { locale: 'zh' },
    { locale: 'ja' }
  ];
}

export const revalidate = 3600; // 每小时重新生成
```

## 📈 监控和分析

### 1. 性能监控设置

**A. Web Vitals 监控**
```typescript
// pages/_app.tsx 或 app/layout.tsx
import { reportWebVitals } from '@/lib/analytics';

export function reportWebVitals(metric: NextWebVitalsMetric) {
  // 发送到分析服务
  if (process.env.NODE_ENV === 'production') {
    analytics.track('Web Vital', {
      name: metric.name,
      value: metric.value,
      id: metric.id,
    });
  }
}
```

**B. 用户体验监控**
```typescript
// 监控关键用户操作
const trackPerformance = {
  imageGeneration: (startTime: number) => {
    const duration = Date.now() - startTime;
    analytics.track('AI Generation Performance', { duration });
  },
  pageLoad: (route: string, loadTime: number) => {
    analytics.track('Page Load', { route, loadTime });
  }
};
```

### 2. 错误监控

```typescript
// 添加错误边界和监控
import { captureException } from '@/lib/sentry';

export function GlobalErrorBoundary({ error }: { error: Error }) {
  useEffect(() => {
    captureException(error);
  }, [error]);
  
  return <ErrorUI error={error} />;
}
```

## 🎯 具体实施计划

### 第一阶段（立即实施）
1. ✅ 修复所有 TypeScript 错误
2. ⚡ 将关键 `<img>` 标签替换为 `<Image>` 组件
3. 📦 启用 bundle analyzer 分析包大小
4. ⚙️ 优化 Vercel 函数配置

### 第二阶段（1-2周内）
1. 🔄 实施 Redis 缓存层
2. 🎨 优化图片加载策略
3. 📊 添加性能监控
4. 🗃️ 数据库查询优化

### 第三阶段（长期优化）
1. 🌐 CDN 和边缘计算优化
2. 🤖 AI API 调用优化
3. 📱 移动端性能优化
4. 🔍 SEO 和 Core Web Vitals 优化

## 📊 预期性能提升

通过实施上述优化，预期可以获得：

| 指标 | 当前 | 目标 | 提升 |
|------|------|------|------|
| 首页加载时间 | ~3s | ~1.5s | 50% |
| 图片加载时间 | ~2s | ~0.8s | 60% |
| API 响应时间 | ~500ms | ~200ms | 60% |
| Lighthouse 评分 | ~70 | ~90+ | 20+ |
| Bundle 大小 | 730 kB | ~500 kB | 30% |

## 🔧 工具和资源

### 性能分析工具
- **Lighthouse:** 综合性能评估
- **GTmetrix:** 页面加载分析
- **WebPageTest:** 详细性能测试
- **Vercel Analytics:** 实时用户监控

### 优化工具
- **Bundle Analyzer:** JavaScript 包分析
- **ImageOptim:** 图片压缩
- **Sharp:** 服务端图片处理
- **Redis:** 缓存层

---

**最后更新：** 2024年12月
**文档版本：** 1.0

> 💡 **建议：** 性能优化是一个持续的过程。建议每月进行一次性能审查，根据用户反馈和监控数据调整优化策略。